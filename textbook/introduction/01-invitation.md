---
title: "1. dbtへの招待"
---

# 1. dbtへの招待

この章では、dbtが登場する前のデータパイプラインの課題と、dbtがどのようにそれらを解決するのかを理解しましょう。

## 1-1. データパイプラインの課題

あなたはデータアナリストとして、会社の売上データを分析する仕事を任されたとします。データは複数のシステムに散らばっていて、以下のような状況かもしれません：

### 課題1: SQLファイルの乱立

```
📂 sql_queries/
├── daily_sales_v1.sql
├── daily_sales_v2.sql
├── daily_sales_final.sql
├── daily_sales_final_v2.sql
├── customer_analysis_202401.sql
├── customer_analysis_202402.sql
└── ...（以下数百ファイル）
```

「どのSQLが最新版？」「このSQLは何のために作ったんだっけ？」という状況に心当たりはありませんか？

### 課題2: 依存関係の管理

```sql
-- daily_report.sql
SELECT *
FROM customer_summary  -- これってどのSQLで作られたテーブル？
JOIN order_aggregates  -- これも何？
```

あるクエリが別のクエリの結果に依存している場合、実行順序を手動で管理する必要があります。「あ、テーブルAを作り忘れてた」というミスも頻発します。

### 課題3: データ品質の担保

```sql
-- 気づけば売上がマイナスになっている...
SELECT SUM(amount) FROM orders;
-- 結果: -1,000,000円
```

データに不整合があっても、分析結果が出るまで気づかないことがよくあります。

### 課題4: ドキュメントの不在

「この項目の意味は？」「データはどこから来ているの？」といった質問に答えるために、都度SQLを読み解く必要があります。

:::message
これらの課題は、組織が大きくなるほど深刻になります。1人のアナリストなら頭で管理できていても、チームになると破綻します。
:::

## 1-2. dbtが解決する問題

dbtは、これらの課題を以下のように解決します：

### 解決1: バージョン管理されたSQL

```
📂 models/
├── staging/
│   └── stg_orders.sql
├── intermediate/
│   └── int_order_summary.sql
└── marts/
    └── fct_daily_sales.sql
```

- Gitで管理されるため、変更履歴が追える
- 誰がいつ何を変更したかが明確
- ロールバックも簡単

### 解決2: 自動的な依存関係管理

```sql
-- fct_daily_sales.sql
SELECT *
FROM {{ ref('int_order_summary') }}  -- dbtが自動で依存関係を解決
```

- `ref()`関数を使うと、dbtが依存関係を自動的に解決
- 正しい順序でクエリを実行してくれる
- 循環依存も検出可能

### 解決3: 組み込みのデータテスト

```yaml
# schema.yml
columns:
  - name: order_id
    tests:
      - unique
      - not_null
```

- データ品質ルールをコードで定義
- テストを自動実行して、問題を早期発見

### 解決4: 自動ドキュメント生成

```
dbt docs generate
dbt docs serve
```

- コードからドキュメントを自動生成
- データリネージ（データの流れ）を可視化
- 常に最新の状態を維持

## 1-3. ELTアプローチの理解

dbtを理解するには、ETLとELTの違いを理解する必要があります。

### 従来のETL

```
[ソース] → [Extract] → [Transform] → [Load] → [DWH]
                         ↑
                    ETLツール
                  (Informatica等)
```

- データをウェアハウスにロードする前に変換
- 専用のETLツールが必要（高額、学習コストが高い）
- 複雑なGUIで設定

### モダンなELT

```
[ソース] → [Extract] → [Load] → [DWH] → [Transform]
                                    ↑
                                  dbt
                            (SQLで記述)
```

- まず生データをウェアハウスにロード
- ウェアハウス内でSQLを使って変換
- dbtは変換部分のみを担当

:::message alert
**なぜELTなのか？**

クラウドデータウェアハウス（BigQuery、Snowflake等）の登場により、ウェアハウス内での処理が高速・安価になりました。これにより、変換もウェアハウス内で行うELTアプローチが主流になっています。
:::

## 1-4. dbtを使うメリット

### SQLだけで完結

```sql
-- Pythonや他の言語を覚える必要がない
SELECT
    customer_id,
    SUM(amount) as total_amount
FROM {{ ref('stg_orders') }}
GROUP BY customer_id
```

データアナリストやデータサイエンティストは、新しい言語を覚えることなく、既存のSQLスキルを活かせます。

### ソフトウェアエンジニアリングのベストプラクティス

- **バージョン管理**: Gitでコードを管理
- **モジュール化**: 再利用可能なコンポーネント
- **テスト**: データ品質の自動チェック
- **CI/CD**: 継続的インテグレーション/デリバリー

### データ民主化

データエンジニアだけでなく、データアナリストもデータパイプラインを構築・保守できるようになります。

## 1-5. 本書で学ぶこと

本書では、以下のステップでdbtを学びます：

1. **入門編**: dbtの概要と環境構築
2. **初級編**: 基本的なプロジェクト構築
3. **中級編**: 本格的な運用と高度な機能

それぞれの章で、実際に手を動かしながら学んでいきましょう。

## まとめ

- データパイプラインには「SQLの乱立」「依存関係の管理」「データ品質」「ドキュメント」という課題がある
- dbtはこれらの課題を解決するツール
- ELTアプローチでは、ウェアハウス内でSQLを使ってデータを変換
- SQLだけでデータパイプラインを構築できる

次の章では、dbtの概要をより詳しく見ていきます。

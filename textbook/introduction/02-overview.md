---
title: "2. dbtの概要"
---

# 2. dbtの概要

この章では、dbtのアーキテクチャと基本的な概念を理解しましょう。

## 2-1. dbtとは

**dbt（data build tool）** は、SQLを使ってデータ変換パイプラインを構築するためのツールです。

公式サイトでは以下のように説明されています：

> dbt enables data analysts and engineers to transform their data using the same practices that software engineers use to build applications.
>
> （dbtは、ソフトウェアエンジニアがアプリケーションを構築する際と同じ手法で、データアナリストやエンジニアがデータを変換できるようにします。）

### dbtが「しない」こと

dbtを理解する上で重要なのは、dbtが**何をしないか**を知ることです：

| しないこと | 責任を持つツール |
|-----------|----------------|
| データの抽出（Extract） | Fivetran, Airbyte, カスタムスクリプト |
| データのロード（Load） | Fivetran, BigQuery Data Transfer |
| データの保存 | データウェアハウス（BigQuery, Snowflake等） |
| スケジューリング | dbt Cloud, Airflow, Prefect |

**dbtがすること**: データの変換（Transform）のみ

:::message
dbtは「T（Transform）」の専門ツールです。これにより、ツールの役割が明確になり、シンプルで強力なツールになっています。
:::

## 2-2. dbt Core vs dbt Cloud

dbtには2つのエディションがあります：

### dbt Core（オープンソース・無料）

```
特徴：
✓ CLI（コマンドライン）で操作
✓ 無料で使用可能
✓ 自由度が高い

制限：
✗ スケジューリング機能なし（外部ツールが必要）
✗ CI/CDは自分で構築する必要がある
✗ Web UIなし
```

### dbt Cloud（有料）

```
特徴：
✓ Web UIで操作
✓ 組み込みのスケジューリング
✓ CI/CDが統合済み
✓ チームコラボレーション機能

制限：
✗ 有料（Freeプランもあり、制限付き）
```

本書では主に **dbt Core** を使用します。理由は以下の通りです：

1. 無料で学習できる
2. 仕組みを深く理解できる
3. 本番環境での選択肢としても有力

:::message
dbt CloudのFreeプランは1ユーザー・1プロジェクトまで無料で使用できます。学習目的であれば十分です。
:::

## 2-3. dbtのアーキテクチャ

### 基本的な流れ

```
┌─────────────────────────────────────────────────────────────┐
│                     ソースデータ                             │
│  (Fivetran等でロードされた生データ)                         │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                    Staging 層                               │
│  ・生データのクリーニング                                    │
│  ・カラム名の統一                                           │
│  ・基本的な型変換                                           │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                  Intermediate 層                            │
│  ・ビジネスロジックの実装                                    │
│  ・結合と集計                                               │
│  ・複雑な変換                                               │
└─────────────────────────────────────────────────────────────┘
                              ↓
┌─────────────────────────────────────────────────────────────┐
│                      Marts 層                               │
│  ・ビジネスユーザー向けモデル                               │
│  ・ファクトテーブル・ディメンションテーブル                  │
│  ・分析用の最終形                                           │
└─────────────────────────────────────────────────────────────┘
```

### 主要コンポーネント

| コンポーネント | 説明 |
|--------------|------|
| **Model** | SQLファイルで定義されたデータ変換ロジック |
| **Source** | 生データのソース定義 |
| **Seed** | CSVファイルからの静的データ |
| **Macro** | 再利用可能なSQLコード片（関数のようなもの） |
| **Test** | データ品質を検証するルール |
| **Snapshot** | データの履歴管理 |
| **Documentation** | モデルの説明とリネージ |

## 2-4. dbtの主要コマンド

| コマンド | 説明 |
|---------|------|
| `dbt init` | 新しいプロジェクトを作成 |
| `dbt run` | モデルを実行してテーブル/ビューを作成 |
| `dbt test` | テストを実行 |
| `dbt compile` | SQLをコンパイル（実行はしない） |
| `dbt docs generate` | ドキュメントを生成 |
| `dbt docs serve` | ドキュメントをローカルサーバーで表示 |
| `dbt debug` | 接続設定を確認 |
| `dbt clean` | 生成物を削除 |
| `dbt deps` | パッケージをインストール |

最もよく使うのは `dbt run` と `dbt test` です。

## 2-5. 対応データウェアハウス

dbtは多くのデータウェアハウスに対応しています：

### 主要アダプタ

| アダプタ | データウェアハウス |
|---------|------------------|
| `dbt-bigquery` | Google BigQuery |
| `dbt-snowflake` | Snowflake |
| `dbt-redshift` | Amazon Redshift |
| `dbt-postgres` | PostgreSQL |
| `dbt-duckdb` | DuckDB |
| `dbt-spark` | Apache Spark / Databricks |

本書では主に **BigQuery** を使用しますが、**DuckDB** も学習用として使用できます。

:::message alert
**DuckDBの利点**

DuckDBはローカル環境で動作するため、以下の利点があります：
- クラウドアカウントが不要
- 課金を気にせず学習できる
- インストールだけで使用可能
- 高速なクエリ実行

学習目的や小規模なプロジェクトには最適です。
:::

## 2-6. Jinjaテンプレートの基礎

dbtはJinjaテンプレートエンジンを使用して、SQLに動的な要素を追加できます。

### 基本的な構文

```sql
-- 変数の使用
SELECT * FROM {{ var('my_variable') }}

-- 条件分岐
SELECT *
{% if is_incremental() %}
WHERE created_at > (SELECT MAX(created_at) FROM {{ this }})
{% endif %}

-- ループ
{% for column in ['a', 'b', 'c'] %}
SUM({{ column }}) as {{ column }}_sum{{ "," if not loop.last }}
{% endfor %}
```

### よく使う組み込み関数

```sql
-- 他のモデルを参照
SELECT * FROM {{ ref('stg_orders') }}

-- ソースを参照
SELECT * FROM {{ source('raw', 'orders') }}

-- 現在のモデル名を取得
-- {{ this }} -> `project_name.schema.model_name`

-- 設定値を取得
-- {{ config.get('materialized') }}
```

Jinjaについては中級編で詳しく解説します。最初は `ref()` と `source()` だけ覚えておけば十分です。

## 2-7. マテリアライゼーション

マテリアライゼーションは、モデルがどのようにデータウェアハウスに実体化されるかを決定します：

| タイプ | 説明 | 使用場面 |
|-------|------|---------|
| **view** | ビューとして作成 | 変更が少ないモデル |
| **table** | テーブルとして作成 | 頻繁にクエリされるモデル |
| **incremental** | 増分更新 | 大量データの更新 |
| **ephemeral** | CTEとして展開 | 中間モデル |

```sql
-- モデル内で設定
{{ config(materialized='table') }}

SELECT * FROM {{ ref('stg_orders') }}
```

デフォルトは `view` です。初級編で詳しく解説します。

## まとめ

- dbtはデータの変換（Transform）に特化したツール
- dbt Core（無料・CLI）と dbt Cloud（有料・Web UI）がある
- 主なコンポーネントは Model, Source, Test, Macro, Snapshot
- JinjaテンプレートでSQLに動的な要素を追加できる
- マテリアライゼーションでデータの実体化方法を制御

次の章では、実際に環境構築を行います。
